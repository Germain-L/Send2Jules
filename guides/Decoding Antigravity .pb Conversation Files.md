# **Technical Forensics of Google Antigravity: Reverse Engineering Protocol Buffer Storage and Agentic State Persistence**

## **1\. Introduction: The Paradigm Shift to Agentic Data Persistence**

The release of Google Antigravity marks a pivotal transition in the trajectory of software development environments, moving from the "Assistant Era" of tools like GitHub Copilot and standard VS Code into the "Agent-First Era".1 Unlike its predecessors, which primarily function as sophisticated autocomplete engines or reactive chat interfaces, Antigravity is architected as a "Mission Control" for autonomous agents capable of planning, executing, and verifying complex engineering tasks with minimal human intervention.3 This fundamental shift in operational logic—from synchronous text editing to asynchronous task orchestration—necessitates a radically different approach to data persistence and state management.  
In a traditional Integrated Development Environment (IDE), the primary "truth" is the source code stored on the disk. The IDE's state is ephemeral, consisting mostly of open tabs and undo stacks. In Antigravity, however, the "truth" encompasses the agent's reasoning chains, the "Thought Signatures" generated by the Gemini 3 model, multi-turn conversation histories, implementation plans, and the verification artifacts produced during execution.3 The persistence of this data is not merely a convenience but a functional requirement for the agent's ability to maintain context over long horizons and resume tasks after interruptions.  
For researchers, forensic analysts, and developers seeking to audit these autonomous behaviors, the opacity of Antigravity’s storage mechanisms presents a significant challenge. The platform leverages Google's proprietary but open-source-adjacent infrastructure, specifically relying on Protocol Buffers (protobuf) for high-efficiency serialization without providing the accompanying schema definitions (.proto files).5 This report provides an exhaustive technical analysis of Antigravity’s storage architecture, detailing the locations, formats, and decoding methodologies required to access these internal conversation logs. By synthesizing forensic analysis of the VS Code foundation, the Electron runtime environment, and the Gemini 3 SDK, we establish a verifiable pathway to reconstructing the agent's internal monologue and execution history.

### **1.1 The Evolution from VS Code to Antigravity**

To understand where data is hidden, one must first understand the vessel. Antigravity is not built from scratch; it is a sophisticated fork of Visual Studio Code (VS Code), leveraging the Electron framework to deliver a cross-platform desktop experience.7 This lineage is the single most critical factor in locating user data. Because it shares the VS Code DNA, it inherits specific behaviors regarding file system hierarchy, SQLite database usage for state management, and extension isolation.9  
However, Antigravity diverges significantly in how it handles "extensions." In a standard VS Code environment, an AI tool is just a plugin with limited access. In Antigravity, the agent is a first-class citizen integrated directly into the core UI via the "Agent Manager" surface.1 This integration suggests that conversation histories are likely stored in the global application state or specialized workspace storage containers rather than in ephemeral extension folders. Furthermore, the introduction of the "Three Surface" architecture—comprising the Editor, the Agent Manager, and the integrated Browser—implies a fragmented data landscape where user interactions are split across different storage backends.11

### **1.2 The Imperative of Protocol Buffers**

Google's choice of Protocol Buffers for storing interaction data is driven by performance and backward compatibility. Protobuf is a binary format that is significantly smaller and faster to parse than JSON or XML, which is essential when storing the massive context windows (up to millions of tokens) supported by Gemini 3\.13 However, this efficiency comes at the cost of readability. A raw .pb file contains field numbers and values but no names. Without the schema, a field containing the integer 1732048596 could be a timestamp, a user ID, or a configuration flag.15  
The forensic challenge, therefore, is not just decryption (though encryption may be present) but *semantic reconstruction*. We must deduce the meaning of the data fields by analyzing their structure (wire types), their values (heuristics), and their context within the broader file system. This report outlines the specific methodologies to achieve this, leveraging tools like protoc \--decode\_raw and blackboxprotobuf to bridge the gap between binary obfuscation and human-readable logs.  
---

## **2\. Architectural Reconnaissance: Locating the Target Data**

The first step in any reverse-engineering effort is establishing the physical location of the data artifacts. Due to Antigravity's hybrid nature—part VS Code fork, part Gemini 3 client—the data is distributed across standard OS application paths and proprietary Google configuration directories.

### **2.1 The Electron Storage Hierarchy**

As an Electron application, Antigravity adheres to the Chromium standard for user data directories. This provides a predictable starting point for investigation. The "User Data" directory contains profile data, local storage, and, crucially, the SQLite databases used by the application framework to persist state.10  
**Table 1: Primary Data Storage Vectors by Operating System**

| Operating System | Base User Data Path | Workspace Storage Location | CLI & Global Config |
| :---- | :---- | :---- | :---- |
| **Windows** | %APPDATA%\\Antigravity\\User\\ | %APPDATA%\\Antigravity\\User\\workspaceStorage\\ | C:\\Users\\{User}\\.gemini\\ |
| **macOS** | \~/Library/Application Support/Antigravity/User/ | \~/Library/Application Support/Antigravity/User/workspaceStorage/ | \~/.gemini/ |
| **Linux** | \~/.config/Antigravity/User/ | \~/.config/Antigravity/User/workspaceStorage/ | \~/.gemini/ |

Note: The workspaceStorage directory contains subfolders named with 32-character hexadecimal hashes. Each folder corresponds to a specific project or "workspace" opened in the IDE.16

### **2.2 The state.vscdb Container**

Within each hashed workspace folder, the most significant file for forensic analysis is state.vscdb.16 This is a standard SQLite database that VS Code (and thus Antigravity) uses as a key-value store for the session.

* **Mechanism:** When a user opens a chat pane or the "Agent Manager," the history of that session is serialized and written to this database to ensure it persists across restarts.  
* **Key Identification:** Unlike a typical relational database with columns for "Message" or "Sender," the state.vscdb uses a single table, typically named ItemTable, with key and value columns. The conversation data is stored as a BLOB in the value column, associated with keys that likely follow patterns such as workbench.panel.chat, antigravity.agentManager.history, or memento/interactive-session.18  
* **Content:** The BLOB stored in this database is rarely plain text. To optimize for the "Thought Signatures" and rich media artifacts involved in Gemini 3 interactions, this BLOB is almost certainly a serialized Protocol Buffer message.16

### **2.3 The \~/.gemini Global Directory**

Distinct from the Electron storage, Antigravity leverages shared components with the Gemini CLI. Research snippets indicate the existence of a \~/.gemini directory (or .gemini in the user profile on Windows).19

* **Shared Authentication & Config:** This directory houses the mcp\_config.json file, which configures the Model Context Protocol (MCP) servers that allow the agent to interact with external tools and local files.19  
* **Checkpoints:** The Gemini CLI uses a subdirectory structure like \~/.gemini/tmp/\<project\_hash\>/ to store conversation checkpoints.20 It is highly probable that Antigravity mirrors this behavior, creating redundant or cache copies of conversation logs in this location, potentially in a format that is easier to parse than the SQLite-embedded blobs. These checkpoints are critical for the "time travel" or "branching" capabilities of the agent, allowing users to revert the agent's state to a previous point in the conversation.20

### **2.4 Artifact Storage (.antigravity and AGENTS.md)**

While conversation *logs* are binary, the *outputs* of the agent are often text-based artifacts stored directly in the project workspace.

* **The .antigravity Folder:** Many agentic workflows generate a hidden .antigravity folder in the project root. This may contain rules.md, implementation plans, and "Walkthrough" artifacts.22  
* **AGENTS.md:** This file acts as a README for machines, providing the agent with context about the project structure, coding conventions, and build commands.23 While this is an *input* rather than a log, its presence is a strong indicator of an active agentic workflow, and the agent's adherence to these rules can often be verified by cross-referencing the AGENTS.md content with the binary instruction logs.

---

## **3\. Deep Dive: The Protocol Buffer Wire Format**

To read the conversation logs, one must understand the language in which they are written. Protocol Buffers are not encrypted in the traditional sense, but they are encoded in a binary format that is hostile to casual inspection.

### **3.1 The "Missing Schema" Problem**

In a standard Protobuf workflow, a developer defines a .proto file (e.g., message ChatLog { string user \= 1; string text \= 2; }). The compiler generates code to read this. Antigravity includes the compiled code but not the source .proto file.

* **Implication:** When we extract the binary blob from state.vscdb, we see a stream of bytes. We can decode the structure (e.g., "Field 1 is a string of length 5"), but we do not know if Field 1 is the "User Name" or the "Message ID".5  
* **Resolution:** We must rely on "Reverse Engineering via Context." By observing the data contained in the fields (e.g., seeing a string "Hello Gemini"), we can infer the semantic meaning of the field IDs.

### **3.2 Wire Types and Decoding Logic**

The Protobuf wire format is built on **Varints** (Variable Integers). A varint is a way of serializing integers using one or more bytes. Smaller numbers take fewer bytes. The key to decoding the logs is identifying the **Tag**, which combines the Field ID and the Wire Type.15  
**Table 2: Protocol Buffer Wire Types Relevant to Antigravity Logs**

| Type ID | Name | Python/C++ Type | Usage in Chat Logs | Decoding Strategy |
| :---- | :---- | :---- | :---- | :---- |
| **0** | Varint | int32, int64, bool, enum | Timestamps (Unix epoch), Message Status (Sent/Received), Error Codes. | Read as variable-length integer (1-10 bytes). |
| **1** | 64-bit | fixed64, double | Precise coordinates, high-fidelity timestamps. | Read next 8 bytes as little-endian. |
| **2** | Length-delimited | string, bytes, embedded messages | **The Most Critical Type.** Used for text content, nested messages (e.g., a list of chats), and binary artifacts (Thought Signatures). | Read Varint length $N$, then read $N$ bytes. Attempt UTF-8 decode; if fail, treat as binary or nested message. |
| **5** | 32-bit | fixed32, float | Less common in text logs. | Read next 4 bytes. |

Source: 15

### **3.3 The Recursive Structure of Conversation Histories**

Chat logs are inherently hierarchical (recursive). The binary blob found in state.vscdb will likely follow a structure similar to this:

1. **Root Message (Conversation Container):** Contains metadata (Project ID, Model Version).  
2. **Repeated Field (The Turns):** A list of child messages, each representing a single turn in the conversation.  
3. **Child Message (The Turn):** Contains specific fields:  
   * **Role:** User vs. Agent (String or Enum).  
   * **Content:** The text of the message (String).  
   * **Timestamp:** When it happened (Varint).  
   * **Thought Signature:** The internal reasoning state (Bytes).4  
   * **Artifact Links:** References to files created (String/List).

This recursive structure can be identified in the raw binary by seeing a repeated Field ID with Wire Type 2\. For example, if Field ID 5 appears twenty times, and each time it contains a payload that *also* decodes as a valid Protobuf message, Field 5 is the "Message List".15  
---

## **4\. Methodology: Forensic Extraction and Decoding**

This section details the practical, step-by-step methodology for extracting and decoding the logs. This workflow assumes a standard installation on a Windows or macOS machine.

### **4.1 Phase 1: Database Extraction**

Directly reading the state.vscdb file while Antigravity is running is risky due to file locking (WAL mode).

1. **Close Antigravity:** Ensure the application is fully terminated to flush the Write-Ahead Log (WAL) to the main database file.  
2. **Locate the Workspace Folder:** Navigate to %APPDATA%\\Antigravity\\User\\workspaceStorage\\ (Windows) or the equivalent Mac/Linux path. Sort folders by "Date Modified" to find the most recent session.  
3. **Open the Database:** Use a tool like sqlite3 or *DB Browser for SQLite* to open state.vscdb.  
4. Query the ItemTable:  
   The data is stored in the ItemTable. We need to find the row containing the chat history. The key names differ between VS Code forks, but common substrings allow for discovery.  
   SQL  
   SELECT key, value   
   FROM ItemTable   
   WHERE key LIKE '%antigravity%'   
      OR key LIKE '%chat%'   
      OR key LIKE '%interactive%'  
      OR key LIKE '%workbench.panel%';

   *Insight:* Research suggests that keys like antigravity.agentManager.history or memento/interactive-session are the primary targets.16  
5. **Export the Blob:** Once the row is identified, export the binary data in the value column to a file, e.g., raw\_blob.bin.

### **4.2 Phase 2: Sanitizing the Blob**

VS Code often wraps the raw Protobuf data in a proprietary header or a JSON envelope before storing it in the SQLite column.

* **Heuristic Analysis:** Open raw\_blob.bin in a hex editor.  
  * Does it start with {? It's a JSON wrapper. The Protobuf data is likely Base64 encoded inside a value within this JSON. Decode the Base64 to get the real .pb file.  
  * Does it start with a version number or string (e.g., VSCODE\_1.0)? Delete these bytes until you reach the first byte that looks like a valid Protobuf tag (commonly 08, 0A, 10, 12, 18, 1A hex).6  
* **Save:** Save the sanitized binary as clean\_log.pb.

### **4.3 Phase 3: protoc \--decode\_raw Analysis**

The most powerful tool for this phase is the official Protobuf compiler, protoc, which includes a raw decoding mode.24

* **Command:**  
  Bash  
  protoc \--decode\_raw \< clean\_log.pb \> decoded\_tree.txt

* Interpreting the Output: The output will be a hierarchical text representation.  
  1: "conversation\_id\_8923"  
  2 {  
  1: "user"  
  2: "Create a Python script for scraping"  
  3: 1732048800  
  }  
  2 {  
  1: "model"  
  2: "I will create the script using BeautifulSoup..."  
  4: "\\023\\045\\112..." \<-- (Binary Blob / Thought Signature)  
  }  
  Analysis: In this hypothetical output:  
  * **Field 1** (Wire Type 2\) is likely the Session ID.  
  * **Field 2** (Wire Type 2, Repeated) is the Message object.  
  * **Field 2 \-\> Field 1** is the Role (User/Model).  
  * **Field 2 \-\> Field 2** is the Text Content.  
  * **Field 2 \-\> Field 4** is the Thought Signature.4

### **4.4 Phase 4: Automated Reconstruction via Python**

For large datasets, manual inspection is infeasible. We can script the extraction using the blackboxprotobuf library, which automates the type-guessing logic.26

Python

import sqlite3  
import blackboxprotobuf  
import json  
import os

\# Configuration  
\# Replace with your specific hash folder  
DB\_PATH \= os.path.expandvars(r'%APPDATA%\\Antigravity\\User\\workspaceStorage\\\<HASH\>\\state.vscdb') 

def extract\_chat\_history():  
    conn \= sqlite3.connect(DB\_PATH)  
    cursor \= conn.cursor()  
      
    \# Locate the specific key for Antigravity history  
    cursor.execute("SELECT value FROM ItemTable WHERE key LIKE '%antigravity%history%'")  
    row \= cursor.fetchone()  
      
    if row:  
        blob\_data \= row  
          
        \# Attempt to decode the message  
        \# blackboxprotobuf returns a dictionary and a type definition  
        try:  
            message, typedef \= blackboxprotobuf.decode\_message(blob\_data)  
              
            \# Navigate the dictionary to find text fields  
            \# This requires exploring the 'message' dict structure  
            print(json.dumps(message, indent=2, default=str))  
              
        except Exception as e:  
            print(f"Decoding failed: {e}")  
    else:  
        print("No history key found.")

if \_\_name\_\_ \== "\_\_main\_\_":  
    extract\_chat\_history()

*Note: This script assumes the blob is pure Protobuf. If JSON wrapping is present, a JSON parsing step must be added before decode\_message.*  
---

## **5\. The Role of "Thought Signatures" and Encrypted State**

A unique and critical component of the Antigravity data structure is the "Thought Signature," a concept introduced with the Gemini 3 model architecture.4

### **5.1 Mechanism and Purpose**

Thought Signatures are encrypted representations of the model's internal chain of thought. In an agentic workflow, the model performs multiple steps (Reasoning \-\> Tool Call \-\> Observation \-\> Reasoning). To maintain coherence across these steps without re-processing the entire context window every time, the model outputs a condensed, encrypted state vector—the Thought Signature.27

* **Storage:** These signatures must be passed back to the model in subsequent API calls. Therefore, they must be stored in the local history logs.  
* **Appearance:** In the decoded Protobuf output, these will appear as large, high-entropy byte strings (Wire Type 2\) that do not decode to UTF-8 text.

### **5.2 Implications for Reverse Engineering**

* **Unreadable Content:** It is impossible for a user to "decrypt" these signatures to read the model's hidden thoughts. The encryption keys are held by Google's backend infrastructure.  
* **Data Volume:** These signatures significantly inflate the size of the .pb files compared to standard text logs.  
* **Filtering Strategy:** When writing a parser to read the chat logs, researchers must identify the field ID corresponding to the Thought Signature and *exclude* it from the text transcript to produce a readable output. Typically, if a Type 2 field contains non-printable characters, it should be treated as a binary blob and skipped during text extraction.

---

## **6\. Integration with Model Context Protocol (MCP)**

Antigravity extends its capabilities via the Model Context Protocol (MCP), an open standard that allows the agent to connect to external data sources (PostgreSQL, Notion, filesystem).28 The configuration and logging of MCP interactions provide a secondary vector for data analysis.

### **6.1 mcp\_config.json**

The connection to these tools is governed by the mcp\_config.json file, typically located in \~/.gemini/antigravity/ or the workspace root.19

* **Structure:** This JSON file defines the "Servers" (tools) the agent can access and the arguments used to launch them.  
* **Forensic Value:** By analyzing this file, a researcher can determine exactly what external capabilities the agent had access to (e.g., "Did the agent have access to my production database?").

### **6.2 Intercepting MCP Traffic**

Because MCP operates over standard I/O (stdio) or HTTP, it is possible to intercept the traffic between Antigravity and the MCP servers *without* decoding the Protobuf logs.

* **Forward Engineering:** A developer could modify mcp\_config.json to wrap the standard tool commands in a logging proxy.  
  * *Original:* "command": "npx \-y @modelcontextprotocol/server-filesystem"  
  * *Modified:* "command": "python logger\_proxy.py npx \-y..."  
* **Result:** This proxy would capture every tool call (e.g., readFile, listDir) and every tool result in plain JSON text, creating a real-time audit log of the agent's actions on the system. This offers a "forward-looking" alternative to the "backward-looking" Protobuf decoding.

### **6.3 Agent2Agent (A2A) Protocol Implications**

Google has also introduced the Agent2Agent (A2A) protocol, allowing disparate agents to communicate.30 If Antigravity is configured to use A2A, the logs will contain not just User-Agent interactions, but Agent-Agent handshakes and task delegations.

* **Storage Complexity:** This adds another layer of nesting to the Protobuf structure. A "Turn" might contain a "Delegation" sub-message, which contains the "Remote Agent Response."  
* **Decoding A2A:** The A2A protocol uses standard JSON-based "Agent Cards" for discovery 30, but the actual transmission of context likely occurs within the encrypted channels or the opaque blobs within the Protobuf logs.

---

## **7\. Security, Ethics, and Future Outlook**

The ability to reverse-engineer these logs touches upon significant security and data sovereignty issues.

### **7.1 Data Sovereignty and Encryption**

While the state.vscdb file is generally unencrypted (relying on OS-level user permissions), the *content* within the Protobuf blobs—specifically the Thought Signatures—is opaque. This creates a "Black Box" scenario where users possess the files but not the keys to fully understand the model's internal state. However, the *text* of the conversation (prompts and responses) remains accessible via the methods outlined in this report.

* **Risk:** If an attacker gains access to state.vscdb, they can reconstruct the entire development history, including proprietary code snippets pasted into the chat and potential API keys or secrets discussed with the agent.  
* **Mitigation:** Developers should treat their workspaceStorage folder with the same security sensitivity as their .ssh folder.

### **7.2 The "Death of the Text File"**

Antigravity signals a move toward "Database-Backed Coding." In this paradigm, the code is just one artifact among many (plans, logs, context). As IDEs evolve, we can expect the state.vscdb (or its successor) to become as important as the .git folder. The ability to parse and migrate this data will become a critical requirement for developer tooling, likely forcing Google to eventually release an official export API or open-source the schema.32

## **8\. Conclusion**

Reading Google Antigravity's .pb files is a non-trivial forensic task that requires traversing the Electron/VS Code storage hierarchy and applying heuristic decoding to schema-less Protocol Buffers. While Google does not provide a native export for "Mission Control" history, the data persists locally in SQLite databases (state.vscdb) and global CLI checkpoints (\~/.gemini).  
By extracting the binary blobs from the ItemTable of the SQLite database and utilizing tools like protoc \--decode\_raw or blackboxprotobuf, researchers can reconstruct a readable transcript of the agent's planning, code generation, and verification steps. This process allows for the auditing of autonomous agents and ensures that developers can retain access to the intellectual property generated during their "vibe coding" sessions, effectively bypassing the proprietary lock-in of the current preview interface. As the "Agent-First" era matures, mastering these forensic techniques will be essential for maintaining transparency and control over AI-assisted development workflows.  
---

Data Sources & Citations:

27

#### **Works cited**

1. Getting Started with Google Antigravity, accessed on November 22, 2025, [https://codelabs.developers.google.com/getting-started-google-antigravity](https://codelabs.developers.google.com/getting-started-google-antigravity)  
2. Tutorial : Getting Started with Google Antigravity | by Romin Irani | Google Cloud \- Community | Nov, 2025, accessed on November 22, 2025, [https://medium.com/google-cloud/tutorial-getting-started-with-google-antigravity-b5cc74c103c2](https://medium.com/google-cloud/tutorial-getting-started-with-google-antigravity-b5cc74c103c2)  
3. Build with Google Antigravity, our new agentic development platform, accessed on November 22, 2025, [https://developers.googleblog.com/build-with-google-antigravity-our-new-agentic-development-platform/](https://developers.googleblog.com/build-with-google-antigravity-our-new-agentic-development-platform/)  
4. The Era of Action Model with Gemini 3 Pro & Google Antigravity \- Medium, accessed on November 22, 2025, [https://medium.com/google-cloud/the-era-of-action-with-gemini-3-pro-google-antigravity-853b935c5df0](https://medium.com/google-cloud/the-era-of-action-with-gemini-3-pro-google-antigravity-853b935c5df0)  
5. Parse Google Protocol Buffers datagram without .proto file? \- Stack Overflow, accessed on November 22, 2025, [https://stackoverflow.com/questions/14627069/parse-google-protocol-buffers-datagram-without-proto-file](https://stackoverflow.com/questions/14627069/parse-google-protocol-buffers-datagram-without-proto-file)  
6. Reverse Engineering Protobuf Definitions From Compiled Binaries \- Arkadiy Tetelman, accessed on November 22, 2025, [https://arkadiyt.com/2024/03/03/reverse-engineering-protobuf-definitiions-from-compiled-binaries/](https://arkadiyt.com/2024/03/03/reverse-engineering-protobuf-definitiions-from-compiled-binaries/)  
7. Google Antigravity \- Wikipedia, accessed on November 22, 2025, [https://en.wikipedia.org/wiki/Google\_Antigravity](https://en.wikipedia.org/wiki/Google_Antigravity)  
8. Google's Antigravity \- Another VS Code Fork\! : r/ChatGPTCoding \- Reddit, accessed on November 22, 2025, [https://www.reddit.com/r/ChatGPTCoding/comments/1p0h4gv/googles\_antigravity\_another\_vs\_code\_fork/](https://www.reddit.com/r/ChatGPTCoding/comments/1p0h4gv/googles_antigravity_another_vs_code_fork/)  
9. Has anyone tried Antigravity by Google? Thoughts on the IDE platform, accessed on November 22, 2025, [https://www.reddit.com/r/singularity/comments/1p10h7i/has\_anyone\_tried\_antigravity\_by\_google\_thoughts/](https://www.reddit.com/r/singularity/comments/1p10h7i/has_anyone_tried_antigravity_by_google_thoughts/)  
10. User Data Directory \- Chromium Docs, accessed on November 22, 2025, [https://chromium.googlesource.com/chromium/src/+/HEAD/docs/user\_data\_dir.md](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/user_data_dir.md)  
11. We take a look at Google's Antigravity: Agentic AI development but some frustrations for early adopters, accessed on November 22, 2025, [https://devclass.com/2025/11/19/googles-antigravity-arrives-agentic-ai-development-but-frustrating-for-early-adopters/](https://devclass.com/2025/11/19/googles-antigravity-arrives-agentic-ai-development-but-frustrating-for-early-adopters/)  
12. How to Set Up and Use Google Antigravity \- Codecademy, accessed on November 22, 2025, [https://www.codecademy.com/article/how-to-set-up-and-use-google-antigravity](https://www.codecademy.com/article/how-to-set-up-and-use-google-antigravity)  
13. Overview | Protocol Buffers Documentation, accessed on November 22, 2025, [https://protobuf.dev/overview/](https://protobuf.dev/overview/)  
14. Protocol Buffers: Text Format. When I first started using Google's… | by Nathan North, accessed on November 22, 2025, [https://medium.com/@nathantnorth/protocol-buffers-text-format-14e0584f70a5](https://medium.com/@nathantnorth/protocol-buffers-text-format-14e0584f70a5)  
15. Encoding | Protocol Buffers Documentation, accessed on November 22, 2025, [https://protobuf.dev/programming-guides/encoding/](https://protobuf.dev/programming-guides/encoding/)  
16. Exploring VS Code's Global State \- mattreduce, accessed on November 22, 2025, [https://mattreduce.com/posts/vscode-global-state/](https://mattreduce.com/posts/vscode-global-state/)  
17. output\_peas.txt \- GitHub Gist, accessed on November 22, 2025, [https://gist.github.com/KevinLiebergen/6b86a1caacbb57248353bac3fe31592b](https://gist.github.com/KevinLiebergen/6b86a1caacbb57248353bac3fe31592b)  
18. How to export the chat history of GitHub Copilot Chat? \#57190, accessed on November 22, 2025, [https://github.com/orgs/community/discussions/57190](https://github.com/orgs/community/discussions/57190)  
19. ChromeDevTools/chrome-devtools-mcp \- GitHub, accessed on November 22, 2025, [https://github.com/ChromeDevTools/chrome-devtools-mcp](https://github.com/ChromeDevTools/chrome-devtools-mcp)  
20. CLI Commands \- Gemini CLI, accessed on November 22, 2025, [https://geminicli.com/docs/cli/commands/](https://geminicli.com/docs/cli/commands/)  
21. Agentic Automation in Google Workspace: Bridging Antigravity and Gemini 3.0 \- tanaike, accessed on November 22, 2025, [https://tanaikech.github.io/2025/11/22/agentic-automation-in-google-workspace-bridging-antigravity-and-gemini-3.0/](https://tanaikech.github.io/2025/11/22/agentic-automation-in-google-workspace-bridging-antigravity-and-gemini-3.0/)  
22. study8677/antigravity-workspace-template: The ultimate ... \- GitHub, accessed on November 22, 2025, [https://github.com/study8677/antigravity-workspace-template](https://github.com/study8677/antigravity-workspace-template)  
23. AGENTS.md: The New Standard for AI Coding Assistants | by proflead \- Medium, accessed on November 22, 2025, [https://medium.com/@proflead/agents-md-the-new-standard-for-ai-coding-assistants-af72910928b6](https://medium.com/@proflead/agents-md-the-new-standard-for-ai-coding-assistants-af72910928b6)  
24. Hunting for File Deletion Artifacts in Google File Stream Data | by Ann Bransom \- Medium, accessed on November 22, 2025, [https://medium.com/@annbransom/hunting-for-file-deletion-artifacts-in-google-file-stream-data-7f24a6cca06b](https://medium.com/@annbransom/hunting-for-file-deletion-artifacts-in-google-file-stream-data-7f24a6cca06b)  
25. Convert the output of protoc \--decode\_raw into json \- Stack Overflow, accessed on November 22, 2025, [https://stackoverflow.com/questions/75255453/convert-the-output-of-protoc-decode-raw-into-json](https://stackoverflow.com/questions/75255453/convert-the-output-of-protoc-decode-raw-into-json)  
26. Parsing unknown protobufs with python \- Yogesh Khatri's forensic blog, accessed on November 22, 2025, [http://www.swiftforensics.com/2020/03/parsing-unknown-protobufs-with-python.html](http://www.swiftforensics.com/2020/03/parsing-unknown-protobufs-with-python.html)  
27. Building AI Agents with Google Gemini 3 and Open Source Frameworks, accessed on November 22, 2025, [https://developers.googleblog.com/building-ai-agents-with-google-gemini-3-and-open-source-frameworks/](https://developers.googleblog.com/building-ai-agents-with-google-gemini-3-and-open-source-frameworks/)  
28. Antigravity and PostgreSQL: No gravity, only vibes | by MCP Toolbox for Databases | Google Cloud \- Medium, accessed on November 22, 2025, [https://medium.com/google-cloud/antigravity-and-postgresql-no-gravity-only-vibes-46a7699fd21f](https://medium.com/google-cloud/antigravity-and-postgresql-no-gravity-only-vibes-46a7699fd21f)  
29. How to Use MCP Servers in Windsurf AI (Becoming 10x Developer) \- Apidog, accessed on November 22, 2025, [https://apidog.com/blog/windsurf-mcp-servers/](https://apidog.com/blog/windsurf-mcp-servers/)  
30. Announcing the Agent2Agent Protocol (A2A) \- Google for Developers Blog, accessed on November 22, 2025, [https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/](https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/)  
31. Agent2Agent (A2A) Protocol, accessed on November 22, 2025, [https://a2a-protocol.org/latest/](https://a2a-protocol.org/latest/)  
32. Feature Request: Export or Copy Entire Copilot Chat Conversation in Visual Studio \#160034, accessed on November 22, 2025, [https://github.com/orgs/community/discussions/160034](https://github.com/orgs/community/discussions/160034)  
33. Gemini 3 for developers: New reasoning, agentic capabilities \- Google Blog, accessed on November 22, 2025, [https://blog.google/technology/developers/gemini-3-developers/](https://blog.google/technology/developers/gemini-3-developers/)